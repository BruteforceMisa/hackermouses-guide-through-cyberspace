<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/hackermouses-guide-through-cyberspace/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/hackermouses-guide-through-cyberspace/" rel="alternate" type="text/html" /><updated>2025-05-13T20:32:33+02:00</updated><id>http://localhost:4000/hackermouses-guide-through-cyberspace/feed.xml</id><title type="html">A Hackermouse’s Guide Through Cyberspace</title><subtitle>Cyberblog with infographics on hardware security, side-channel analysis, artficial intelligence and cryptography.</subtitle><entry><title type="html">AI: Deep Learning</title><link href="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Deep-Learning.html" rel="alternate" type="text/html" title="AI: Deep Learning" /><published>2024-11-06T11:47:02+01:00</published><updated>2024-11-06T11:47:02+01:00</updated><id>http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Deep-Learning</id><content type="html" xml:base="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Deep-Learning.html"><![CDATA[<p>By now, you probably have the feeling why the terminology of neural networks and deep learning is used interchangeably. In fact, the neural network is “learning” the decision boundary based on how many datapoints are classified correctly and how many are classified incorrectly. This is done in two steps: the <i>forward pass</i> and the <i>backpropagation step</i>. In the forward pass, the neural network classifies all datapoints given its features. In the backpropagation step, we check how many datapoints are classified correctly. At one point in time, it is not possible to classify more datapoints correctly than we already have: this is our optimum.</p>

<p>But how do we build such a network? A neural network consists of <i>nodes/neurons</i> which are organised in layers. A neural network consists of one input layer, several hidden layers and one output layer. The amount of nodes chosen for the network depends on your dataset. For our coffee &amp; tea dataset, we would define our network as follows:</p>

<p><img src="http://localhost:4000/hackermouses-guide-through-cyberspace/assets/images/DNN.png" alt="image" /></p>

<p>We have three input features, thus we choose three input neurons. Each input neuron is then used to model a feature. The hidden layer we can choose ourselves, depending on the chosen complexity of the model. As we want to classify whether our drink is coffee or tea, we have two output classes. Our output layer consists of two nodes. Our output neurons will model our output classes by using probabilities. Thus, the first output node would denote the probability that our drink is tea, and the second output node would denote the probability that our drink is coffee. Thus, the sum of our output neurons should be approximately 1.</p>

<p><img src="http://localhost:4000/hackermouses-guide-through-cyberspace/assets/images/DNNtraining.png" alt="image" /></p>

<p>To train this network, we feed our first datapoint and label to our network. The network decides which of the features are more important to classify our drink, and which are less important. The <i>weights</i> between the nodes are updated accordingly. Based on the <i>loss</i> - i.e. how many datapoints are classified correctly - the network is adapted. Then, we put our second datapoint and label into the network. This sequence repeats until all datapoints are seen by the network.</p>

<p>It is also possible to show the dataset another time to the network, in case the network has not found an optimum yet. <i>Epoch</i> is the term used in the deep learning community to indicate how many times the whole dataset is passed through the network.</p>

<p><b>Keywords</b></p>
<ul>
<li>Backpropagation step - the step in the learning algorithm where mistakes are corrected by updating the weights</li>
<li>Epoch - terminology for how often the dataset is passed through the network  </li>
<li>Forward pass - the step in the learning algorithm where datapoints are classified </li>
<li>Loss - metric for the amount of mistakes made by the network. This is the function being minimalised  </li>
<li>Neuron- a basic computational unit within a neural network. Information flows through neurons and are multiplied by its weights depending on information importance </li>
<li>Node - same as neuron</li>
<li>Weights - the factor on how important a certain connection is between neurons. Used to give important features/nodes more power in the network and vice versa</li>
</ul>]]></content><author><name></name></author><category term="Infographics" /><category term="artificial-intelligence" /><summary type="html"><![CDATA[By now, you probably have the feeling why the terminology of neural networks and deep learning is used interchangeably. In fact, the neural network is “learning” the decision boundary based on how many datapoints are classified correctly and how many are classified incorrectly. This is done in two steps: the forward pass and the backpropagation step. In the forward pass, the neural network classifies all datapoints given its features. In the backpropagation step, we check how many datapoints are classified correctly. At one point in time, it is not possible to classify more datapoints correctly than we already have: this is our optimum.]]></summary></entry><entry><title type="html">AI: Learning the Decision Boundary</title><link href="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Learning-the-Decision-Boundary.html" rel="alternate" type="text/html" title="AI: Learning the Decision Boundary" /><published>2024-11-06T11:46:02+01:00</published><updated>2024-11-06T11:46:02+01:00</updated><id>http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Learning-the-Decision-Boundary</id><content type="html" xml:base="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Learning-the-Decision-Boundary.html"><![CDATA[<p>Instead of using regular statistics to detect the decision boundary, we can try to learn the function iteratively. This is where <i>neural networks</i> come in handy. By using deep neural networks, we are repeating our statistical analysis iteratively depending on our data.</p>

<p>For example, suppose we have a coffee which is medium bitter and has a lighter colour. When the function is learning, it might misclassify this coffee as tea. Based on this new datapoint, we have to correct the decision boundary. This process - called <i>gradient descent</i> - is repeated many times, until the most optimum decision boundary is found. This means that most datapoints are classified correctly.</p>

<p><img src="http://localhost:4000/hackermouses-guide-through-cyberspace/assets/images/Decisionboundary.png" alt="image" /></p>

<p>Finding a deep neural network with the best decision boundary is therefore an <i>optimisation problem</i>. This can be calculated mathematically (from high school mathematics, you might recall finding global and local minima/maxima using the derivatives). However, it can be the case that there exist multiple minima. Finding the global minimum is one of the challenges in learning such a function.</p>

<p><img src="http://localhost:4000/hackermouses-guide-through-cyberspace/assets/images/Optimum.png" alt="image" /></p>

<p><b>Keywords</b></p>
<ul>
<li>Neural network - a technique inspired on the human brain designed for finding patterns in data</li>
<li>Gradient descent - a technique for finding the optimum of a function interatively</li>
<li>Optimisation problem - the problem of finding the best solution from all feasible solutions</li>
</ul>]]></content><author><name></name></author><category term="Infographics" /><category term="artificial-intelligence" /><summary type="html"><![CDATA[Instead of using regular statistics to detect the decision boundary, we can try to learn the function iteratively. This is where neural networks come in handy. By using deep neural networks, we are repeating our statistical analysis iteratively depending on our data.]]></summary></entry><entry><title type="html">Introduction to Artificial Intelligence &amp;amp; Data</title><link href="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/AI-and-data.html" rel="alternate" type="text/html" title="Introduction to Artificial Intelligence &amp;amp; Data" /><published>2024-11-06T11:43:02+01:00</published><updated>2024-11-06T11:43:02+01:00</updated><id>http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/AI-and-data</id><content type="html" xml:base="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/AI-and-data.html"><![CDATA[<p>Artificial Intelligence, in short AI, is a very broad term with a lot of associations. It is often considered a “black box”, because we are not always how decisions are made by AI. For this blog, I’ll focus on AI from a data science &amp; statistics perspective.</p>

<p>Let’s have a look at our dataset below on coffee &amp; tea.</p>

<p><img src="http://localhost:4000/hackermouses-guide-through-cyberspace/assets/images/AI-data.png" alt="image" /></p>

<p>Each row in our <i>dataset</i> is considered a <i>datapoint</i>. This is one instance of either coffee or tea. A datapoint can have multiple <i>features</i>. These are characteristics used to describe the datapoint. In our example, the features are the colour, amount of caffeine and the bitterness level. Based on these features, we can estimate if our drink is either coffee or tea, which is called the <i>label</i>. In the image above, a <i>decision boundary</i> is visualised based on our current dataset using two features.</p>

<p><b>Keywords</b></p>
<ul>
<li> Datapoint - a single information point in a dataset </li>
<li> Dataset - a collection of datapoints</li>
<li> Decision boundary - the (hyper)surface in machine learning that seperates classes</li> 
<li> Features - characteristics used to describe a certain datapoint</li>
<li> Label - the classification of a certain datapoint into a group </li>

</ul>]]></content><author><name></name></author><category term="Infographics" /><category term="artificial-intelligence" /><summary type="html"><![CDATA[Artificial Intelligence, in short AI, is a very broad term with a lot of associations. It is often considered a “black box”, because we are not always how decisions are made by AI. For this blog, I’ll focus on AI from a data science &amp; statistics perspective.]]></summary></entry><entry><title type="html">AES: the Substitution Box</title><link href="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Sbox.html" rel="alternate" type="text/html" title="AES: the Substitution Box" /><published>2024-11-06T11:31:02+01:00</published><updated>2024-11-06T11:31:02+01:00</updated><id>http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Sbox</id><content type="html" xml:base="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Sbox.html"><![CDATA[<p>One particular part of the AES operation is interesting for a hardware attack. This is the SubBytes operation, where each byte will be substituted with another value using a <i>substitution box</i> (sbox for short). To show how a substitution box works, have a look at the (insecure) defined substitution box below. We want to encode the word “apple” by using this sbox, which results in an output of “bqqmf”. The substitution box used AES has some interesting mathematical properties to make it secure and is non-linear.</p>

<p><img src="http://localhost:4000/hackermouses-guide-through-cyberspace/assets/images/SimpleSbox.png" alt="image" /></p>

<p>As you can see, the substitution box is a byte-wise encoding mechanism. This makes the sbox an interesting point of attack, as we can attack each byte separately. This is called a <i>Divide-and-Conquer</i> attack. By using such an attack, you drastically lower the amount of possible solutions. For a full AES-128 key, the key would have 2^128 possibilities, while with a divide-and-conquer attack, you would have 2^8 * 16 possibilities, which is equal to 2^8 * 2^4 = 2^12.</p>

<p><img src="http://localhost:4000/hackermouses-guide-through-cyberspace/assets/images/DNC.png" alt="image" /></p>

<p>In the previous blog posts, we showed that the AddRoundKey function is applied before applying the sbox. Thus, the output of the sbox is dependent on the key. With the properties that we can attack each byte of the output of the sbox value separately, and that these bytes are dependent on the key, this value is interesting for a side channel attack.</p>

<p><img src="http://localhost:4000/hackermouses-guide-through-cyberspace/assets/images/POI.png" alt="image" /></p>

<p><b>Keywords</b></p>

<ul>
<li>Substitution box - name for the linear mapping between bytes in the SubBytes operation of AES</li>
<li>Divide-and-Conquer attack - an attack technique where the problem is recursively broken down in smaller problems of the same type </li>
</ul>]]></content><author><name></name></author><category term="Infographics" /><category term="encryption" /><summary type="html"><![CDATA[One particular part of the AES operation is interesting for a hardware attack. This is the SubBytes operation, where each byte will be substituted with another value using a substitution box (sbox for short). To show how a substitution box works, have a look at the (insecure) defined substitution box below. We want to encode the word “apple” by using this sbox, which results in an output of “bqqmf”. The substitution box used AES has some interesting mathematical properties to make it secure and is non-linear.]]></summary></entry><entry><title type="html">AES: the Inner Workings</title><link href="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Inners-of-AES.html" rel="alternate" type="text/html" title="AES: the Inner Workings" /><published>2024-11-06T11:29:02+01:00</published><updated>2024-11-06T11:29:02+01:00</updated><id>http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Inners-of-AES</id><content type="html" xml:base="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Inners-of-AES.html"><![CDATA[<p>In this post, we are going to zoom in on the inner workings of one AES block. AES operates in <i>rounds</i>, which are usually 10, 12 or 14 rounds (matching with AES-128, AES-192 and AES-256). The output of each round is xor’ed with a <i>subkey</i>, which is derived from the main key using the key scheduler. How the key scheduler exactly works, is out of the scope for this blog.
AES consists of four main operations: AddRoundKey, SubBytes, ShiftRows &amp; MixColumns. These functions are repeated for the number of rounds. A visualisation of these functions is shown below.</p>

<p><img src="http://localhost:4000/hackermouses-guide-through-cyberspace/assets/images/AESinners.png" alt="image" /></p>

<p>AddRoundKey is the function where the subkey is added to our data. SubBytes is a function where each byte of our data is mapped to another value. ShiftRows and Mixcolumns are functions where our data is shuffled to add dependencies within the encryption for security. The output of one block of AES-128 after 10 rounds, is the ciphertext of this block. As said in the previous posts, depending on the size of the plaintext, this block may be executed multiple times.</p>

<p>In the next post, we will zoom in on the SubBytes function.</p>

<p><b>Keywords</b></p>
<ul>
<li>Round - one set of the four main operations done by AES </li>
<li>Subkey - the key used in the AddRoundKey function of AES. This subkey is derived from the main key using the key scheduler  </li>
</ul>]]></content><author><name></name></author><category term="Infographics" /><category term="encryption" /><summary type="html"><![CDATA[In this post, we are going to zoom in on the inner workings of one AES block. AES operates in rounds, which are usually 10, 12 or 14 rounds (matching with AES-128, AES-192 and AES-256). The output of each round is xor’ed with a subkey, which is derived from the main key using the key scheduler. How the key scheduler exactly works, is out of the scope for this blog. AES consists of four main operations: AddRoundKey, SubBytes, ShiftRows &amp; MixColumns. These functions are repeated for the number of rounds. A visualisation of these functions is shown below.]]></summary></entry><entry><title type="html">Introduction to AES: a Block Cipher</title><link href="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/AES-blockcipher.html" rel="alternate" type="text/html" title="Introduction to AES: a Block Cipher" /><published>2024-11-06T11:27:02+01:00</published><updated>2024-11-06T11:27:02+01:00</updated><id>http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/AES-blockcipher</id><content type="html" xml:base="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/AES-blockcipher.html"><![CDATA[<p>AES (Advanced Encryption Standard) is the NIST-standard for encrypting data and is widely used. AES is a <i>block cipher</i>, which means that the data is encrypted per block. For example, AES-128 denotes that each <i>plaintext</i> is split into blocks of 128 bits and uses a 128-bit <i>key</i> for <i>encryption</i>.</p>

<p>For example, suppose we want to encrypt the plaintext “Hello world, how are you?”. For now, we will consider each character to be represented in 1 byte (= 8 bits). To correctly encrypt our plaintext, it will be split into the following sets:</p>

<p>[hello world, how] + [ are you?]</p>

<p>The first block is exactly 16 bytes, but the second block is 7 bytes short. In AES, 7 bytes of padding will be added to match the block size. For now, we will denote padding as “p”. The schematic for encrypting looks as follows:
[hello world, how] + [ are you?ppppppp]</p>

<p>Each AES block has as input the plaintext and the key, and outputs a <i>ciphertext</i>. The key is derived from the password chosen by the user. A schematic of AES encryption is shown below.</p>

<p><img src="http://localhost:4000/hackermouses-guide-through-cyberspace/assets/images/AESBlockcipher.png" alt="image" /></p>

<p><b>Keywords</b></p>
<ul>
<li>Block cipher - an encryption mechansim where plaintexts are divided in blocks before encrypting</li>
<li>Ciphertext - the text after encryption, which is only decodable for parties having access to the key</li>
<li>Encryption - technique for encoding information in such a way that only authorised parties can obtain the content </li>
<li>Key - the secret value used for encoding &amp; decoding information </li>
<li>Plaintext - the text before encryption, readable for all parties </li>

</ul>]]></content><author><name></name></author><category term="Infographics" /><category term="encryption" /><summary type="html"><![CDATA[AES (Advanced Encryption Standard) is the NIST-standard for encrypting data and is widely used. AES is a block cipher, which means that the data is encrypted per block. For example, AES-128 denotes that each plaintext is split into blocks of 128 bits and uses a 128-bit key for encryption.]]></summary></entry><entry><title type="html">Hardware: Side Channels</title><link href="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Side-Channels.html" rel="alternate" type="text/html" title="Hardware: Side Channels" /><published>2024-11-06T10:08:02+01:00</published><updated>2024-11-06T10:08:02+01:00</updated><id>http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Side-Channels</id><content type="html" xml:base="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Side-Channels.html"><![CDATA[<p><i>Side channels</i> are channels on which information is leaked through the physical properties of the device. These side channels can occur in a more technical setting, but also in a general setting. Examples of general side channels are such as the sound of your keyboard when you are typing in your password, or even the muscles in your hand when you are typing in your pincode when paying. When zooming into the physical components of a device, side channels such as optical emissions, timing delays, electromagnetic emanation and power consumption are observed. For this post, we will zoom in on the power consumption.</p>

<p>In the previous blog post, it was highlighted that a bit consumes more power when it has the value “1” compared to the value “0”. <i> Power traces </i> belonging to this CPU executing code can be obtained by using a oscilloscope, and these traces reflect the values of the bits. By analysis these power traces, it is possible to deduct what the CPU is executing without direct access to the program. Therefore, <i>sensitive information</i> can be obtained by analysing the current flowing through the device. Examples of such sensitive information are passwords or keys of encryption algorithms.</p>

<p>This attack is based on the leakage of information, rather than a mistake in the program or algorithm. Therefore, it is possible to attack mathematically secure cryptograhic algorithms using side channels.</p>

<p><img src="http://localhost:4000/hackermouses-guide-through-cyberspace/assets/images/sidechannel.png" alt="image" /></p>

<p><b>Keywords</b></p>
<ul>
<li>Side channels - channels on which information is leaked through the physical properties of a device </li>
<li>Power traces - the power consumption data of a device when this device is executing a program </li>
<li>Sensitive information - information which should not be publicly known. This can be a key or a password, but also a value derived from such a key</li>

</ul>]]></content><author><name></name></author><category term="Infographics" /><category term="hardware" /><summary type="html"><![CDATA[Side channels are channels on which information is leaked through the physical properties of the device. These side channels can occur in a more technical setting, but also in a general setting. Examples of general side channels are such as the sound of your keyboard when you are typing in your password, or even the muscles in your hand when you are typing in your pincode when paying. When zooming into the physical components of a device, side channels such as optical emissions, timing delays, electromagnetic emanation and power consumption are observed. For this post, we will zoom in on the power consumption.]]></summary></entry><entry><title type="html">Hardware: The CPU</title><link href="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/The-CPU.html" rel="alternate" type="text/html" title="Hardware: The CPU" /><published>2024-11-06T10:04:02+01:00</published><updated>2024-11-06T10:04:02+01:00</updated><id>http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/The-CPU</id><content type="html" xml:base="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/The-CPU.html"><![CDATA[<p>The CPU is the computational unit of a computer. It executes a sequence of <i>instructions</i>, which is provided directly or indirectly by the programmer. Instructions are programmed into the CPU and selected at the time when they are needed. The implementation of the <i>instruction set</i> can be different for a different type of CPU. An example of an instruction would be “read the contents of location x in memory”.</p>

<p>This instruction needs to be encoded in such a way that the CPU understands the instruction. In the basis, a computer operates with current flowing through the device. If we can manipulate the current, we can encode a message. For example, a high current would be 1 and a low current would be 0. With transistors and logic gates, chip/circuit designers encode different operations into a CPU.</p>

<p>For our example, let us assume that the operation “READ” is encoded as “00110010”, followed by the location. The current through the device is manipulated by the circuit, as the chip designer has implemented. For a certain point in time, the CPU get either a low current (bit==0) or a high current (bit==1). This process is regulated by the <i>clock</i>. The decoder component within the CPU would select the correct instruction and execute it. In the image below, a visualisation is given on how instructions are encoded in a computer.</p>

<p><img src="http://localhost:4000/hackermouses-guide-through-cyberspace/assets/images/CPU.png" alt="image" /></p>

<p><b>Keywords</b></p>
<ul>
<li>Instruction - the order given to the CPU to execute </li>
<li>Instruction set - the list of available instructions and their encodings in a CPU </li> 
<li>Clock - the mechanism in the CPU which regulates when the new bit-value </li>
</ul>]]></content><author><name></name></author><category term="Infographics" /><category term="hardware" /><summary type="html"><![CDATA[The CPU is the computational unit of a computer. It executes a sequence of instructions, which is provided directly or indirectly by the programmer. Instructions are programmed into the CPU and selected at the time when they are needed. The implementation of the instruction set can be different for a different type of CPU. An example of an instruction would be “read the contents of location x in memory”.]]></summary></entry><entry><title type="html">Introduction to Hardware Security</title><link href="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Introduction-to-hardwaresecurity.html" rel="alternate" type="text/html" title="Introduction to Hardware Security" /><published>2024-11-06T09:20:02+01:00</published><updated>2024-11-06T09:20:02+01:00</updated><id>http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Introduction-to-hardwaresecurity</id><content type="html" xml:base="http://localhost:4000/hackermouses-guide-through-cyberspace/infographics/2024/11/06/Introduction-to-hardwaresecurity.html"><![CDATA[<p>The field of <i>hardware security</i> refers to protecting the physical components of a computer. It assumes direct access to the hardware and this field includes anything ranging from managing <i>access control</i> to <i>hardware design</i>. Physical security on your hardware is important, as the hardware can be manipulated by an adversarial. This ranges from plugging a malicious USB into a device to reading information from a monitor screen. It can also be performed more technically by observing power consumption or manipulating input current to inject a fault into the hardware.</p>

<p><img src="http://localhost:4000/hackermouses-guide-through-cyberspace/assets/images/physical.png" alt="image" /></p>

<p><b>Keywords</b></p>
<ul>
<li>Access control - a security technique regulating which parties have access to objects in a network or computer</li>
<li>Hardware design - the physical and logical design of the circuits on a computer</li>
<li>Hardware security - the vulnerability protection of the physical components on a computer from unauthorised access</li>
</ul>]]></content><author><name></name></author><category term="Infographics" /><category term="hardware" /><summary type="html"><![CDATA[The field of hardware security refers to protecting the physical components of a computer. It assumes direct access to the hardware and this field includes anything ranging from managing access control to hardware design. Physical security on your hardware is important, as the hardware can be manipulated by an adversarial. This ranges from plugging a malicious USB into a device to reading information from a monitor screen. It can also be performed more technically by observing power consumption or manipulating input current to inject a fault into the hardware.]]></summary></entry></feed>